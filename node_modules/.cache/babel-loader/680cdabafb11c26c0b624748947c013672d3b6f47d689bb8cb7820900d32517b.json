{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/user/Desktop/kipithonteam2/myapp/snowspot-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/user/Desktop/kipithonteam2/myapp/snowspot-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { initMixpanel } from './mixpanel-service';\nimport { AuthType, EmbedEvent } from './types';\nimport { getDOMNode, getRedirectUrl } from './utils';\n// eslint-disable-next-line import/no-cycle\nimport { fetchSessionInfoService, fetchAuthTokenService, fetchAuthService, fetchBasicAuthService, fetchLogoutService, fetchAuthPostService } from './utils/authService';\n// eslint-disable-next-line import/no-mutable-exports\nexport var loggedInStatus = false;\n// eslint-disable-next-line import/no-mutable-exports\nexport var samlAuthWindow = null;\n// eslint-disable-next-line import/no-mutable-exports\nexport var samlCompletionPromise = null;\nvar sessionInfo = null;\nvar releaseVersion = '';\nexport var SSO_REDIRECTION_MARKER_GUID = '5e16222e-ef02-43e9-9fbd-24226bf3ce5b';\nexport var EndPoints = {\n  AUTH_VERIFICATION: '/callosum/v1/session/info',\n  SAML_LOGIN_TEMPLATE: function SAML_LOGIN_TEMPLATE(targetUrl) {\n    return \"/callosum/v1/saml/login?targetURLPath=\".concat(targetUrl);\n  },\n  OIDC_LOGIN_TEMPLATE: function OIDC_LOGIN_TEMPLATE(targetUrl) {\n    return \"/callosum/v1/oidc/login?targetURLPath=\".concat(targetUrl);\n  },\n  TOKEN_LOGIN: '/callosum/v1/session/login/token',\n  BASIC_LOGIN: '/callosum/v1/session/login',\n  LOGOUT: '/callosum/v1/session/logout'\n};\nexport var AuthFailureType;\n(function (AuthFailureType) {\n  AuthFailureType[\"SDK\"] = \"SDK\";\n  AuthFailureType[\"NO_COOKIE_ACCESS\"] = \"NO_COOKIE_ACCESS\";\n  AuthFailureType[\"EXPIRY\"] = \"EXPIRY\";\n  AuthFailureType[\"OTHER\"] = \"OTHER\";\n})(AuthFailureType || (AuthFailureType = {}));\nexport var AuthStatus;\n(function (AuthStatus) {\n  /**\n   * Emits when the SDK fails to authenticate\n   */\n  AuthStatus[\"FAILURE\"] = \"FAILURE\";\n  /**\n   * Emits when the SDK authenticates successfully\n   */\n  AuthStatus[\"SDK_SUCCESS\"] = \"SDK_SUCCESS\";\n  /**\n   * Emits when the app sends an authentication success message\n   */\n  AuthStatus[\"SUCCESS\"] = \"SUCCESS\";\n  /**\n   * Emits when a user logs out\n   */\n  AuthStatus[\"LOGOUT\"] = \"LOGOUT\";\n})(AuthStatus || (AuthStatus = {}));\n/**\n * Check if we are logged into the ThoughtSpot cluster\n * @param thoughtSpotHost The ThoughtSpot cluster hostname or IP\n */\nfunction isLoggedIn(_x) {\n  return _isLoggedIn.apply(this, arguments);\n}\n/**\n * Return releaseVersion if available\n */\nfunction _isLoggedIn() {\n  _isLoggedIn = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(thoughtSpotHost) {\n    var authVerificationUrl, response, sessionInfoResp;\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) switch (_context8.prev = _context8.next) {\n        case 0:\n          authVerificationUrl = \"\".concat(thoughtSpotHost).concat(EndPoints.AUTH_VERIFICATION);\n          response = null;\n          _context8.prev = 2;\n          _context8.next = 5;\n          return fetchSessionInfoService(authVerificationUrl);\n        case 5:\n          response = _context8.sent;\n          _context8.next = 8;\n          return response.json();\n        case 8:\n          sessionInfoResp = _context8.sent;\n          releaseVersion = sessionInfoResp.releaseVersion;\n          _context8.next = 15;\n          break;\n        case 12:\n          _context8.prev = 12;\n          _context8.t0 = _context8[\"catch\"](2);\n          return _context8.abrupt(\"return\", false);\n        case 15:\n          return _context8.abrupt(\"return\", response.status === 200);\n        case 16:\n        case \"end\":\n          return _context8.stop();\n      }\n    }, _callee8, null, [[2, 12]]);\n  }));\n  return _isLoggedIn.apply(this, arguments);\n}\nexport function getReleaseVersion() {\n  return releaseVersion;\n}\n/**\n * Return sessionInfo if available else make a loggedIn check to fetch the sessionInfo\n */\nexport function getSessionInfo() {\n  return sessionInfo;\n}\nexport function initSession(sessionDetails) {\n  sessionInfo = sessionDetails;\n  initMixpanel(sessionInfo);\n}\nvar DUPLICATE_TOKEN_ERR = 'Duplicate token, please issue a new token every time getAuthToken callback is called.' + 'See https://developers.thoughtspot.com/docs/?pageid=embed-auth#trusted-auth-embed for more details.';\nvar prevAuthToken = null;\nfunction alertForDuplicateToken(authtoken) {\n  if (prevAuthToken === authtoken) {\n    // eslint-disable-next-line no-alert\n    alert(DUPLICATE_TOKEN_ERR);\n    throw new Error(DUPLICATE_TOKEN_ERR);\n  }\n  prevAuthToken = authtoken;\n}\n/**\n * Check if we are stuck at the SSO redirect URL\n */\nfunction isAtSSORedirectUrl() {\n  return window.location.href.indexOf(SSO_REDIRECTION_MARKER_GUID) >= 0;\n}\n/**\n * Remove the SSO redirect URL marker\n */\nfunction removeSSORedirectUrlMarker() {\n  // Note (sunny): This will leave a # around even if it was not in the URL\n  // to begin with. Trying to remove the hash by changing window.location will reload\n  // the page which we don't want. We'll live with adding an unnecessary hash to the\n  // parent page URL until we find any use case where that creates an issue.\n  window.location.hash = window.location.hash.replace(SSO_REDIRECTION_MARKER_GUID, '');\n}\n/**\n * Perform token based authentication\n * @param embedConfig The embed configuration\n */\nexport var doTokenAuth = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(embedConfig) {\n    var thoughtSpotHost, username, authEndpoint, getAuthToken, authToken, response, resp;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          thoughtSpotHost = embedConfig.thoughtSpotHost, username = embedConfig.username, authEndpoint = embedConfig.authEndpoint, getAuthToken = embedConfig.getAuthToken;\n          if (!(!authEndpoint && !getAuthToken)) {\n            _context.next = 3;\n            break;\n          }\n          throw new Error('Either auth endpoint or getAuthToken function must be provided');\n        case 3:\n          _context.next = 5;\n          return isLoggedIn(thoughtSpotHost);\n        case 5:\n          loggedInStatus = _context.sent;\n          if (loggedInStatus) {\n            _context.next = 37;\n            break;\n          }\n          authToken = null;\n          if (!getAuthToken) {\n            _context.next = 15;\n            break;\n          }\n          _context.next = 11;\n          return getAuthToken();\n        case 11:\n          authToken = _context.sent;\n          alertForDuplicateToken(authToken);\n          _context.next = 21;\n          break;\n        case 15:\n          _context.next = 17;\n          return fetchAuthTokenService(authEndpoint);\n        case 17:\n          response = _context.sent;\n          _context.next = 20;\n          return response.text();\n        case 20:\n          authToken = _context.sent;\n        case 21:\n          _context.prev = 21;\n          _context.next = 24;\n          return fetchAuthPostService(thoughtSpotHost, username, authToken);\n        case 24:\n          resp = _context.sent;\n          _context.next = 32;\n          break;\n        case 27:\n          _context.prev = 27;\n          _context.t0 = _context[\"catch\"](21);\n          _context.next = 31;\n          return fetchAuthService(thoughtSpotHost, username, authToken);\n        case 31:\n          resp = _context.sent;\n        case 32:\n          // token login issues a 302 when successful\n          loggedInStatus = resp.ok || resp.type === 'opaqueredirect';\n          if (!(loggedInStatus && embedConfig.detectCookieAccessSlow)) {\n            _context.next = 37;\n            break;\n          }\n          _context.next = 36;\n          return isLoggedIn(thoughtSpotHost);\n        case 36:\n          loggedInStatus = _context.sent;\n        case 37:\n          return _context.abrupt(\"return\", loggedInStatus);\n        case 38:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[21, 27]]);\n  }));\n  return function doTokenAuth(_x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Perform basic authentication to the ThoughtSpot cluster using the cluster\n * credentials.\n *\n * Warning: This feature is primarily intended for developer testing. It is\n * strongly advised not to use this authentication method in production.\n * @param embedConfig The embed configuration\n */\nexport var doBasicAuth = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(embedConfig) {\n    var thoughtSpotHost, username, password, loggedIn, response;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          thoughtSpotHost = embedConfig.thoughtSpotHost, username = embedConfig.username, password = embedConfig.password;\n          _context2.next = 3;\n          return isLoggedIn(thoughtSpotHost);\n        case 3:\n          loggedIn = _context2.sent;\n          if (loggedIn) {\n            _context2.next = 15;\n            break;\n          }\n          _context2.next = 7;\n          return fetchBasicAuthService(thoughtSpotHost, username, password);\n        case 7:\n          response = _context2.sent;\n          loggedInStatus = response.ok;\n          if (!embedConfig.detectCookieAccessSlow) {\n            _context2.next = 13;\n            break;\n          }\n          _context2.next = 12;\n          return isLoggedIn(thoughtSpotHost);\n        case 12:\n          loggedInStatus = _context2.sent;\n        case 13:\n          _context2.next = 16;\n          break;\n        case 15:\n          loggedInStatus = true;\n        case 16:\n          return _context2.abrupt(\"return\", loggedInStatus);\n        case 17:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return function doBasicAuth(_x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nfunction samlPopupFlow(_x4, _x5, _x6) {\n  return _samlPopupFlow.apply(this, arguments);\n}\n/**\n * Perform SAML authentication\n * @param embedConfig The embed configuration\n */\nfunction _samlPopupFlow() {\n  _samlPopupFlow = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(ssoURL, triggerContainer, triggerText) {\n    var containerEl, authElem;\n    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n      while (1) switch (_context9.prev = _context9.next) {\n        case 0:\n          containerEl = getDOMNode(triggerContainer);\n          containerEl.innerHTML = '<button id=\"ts-auth-btn\" class=\"ts-auth-btn\" style=\"margin: auto;\"></button>';\n          authElem = document.getElementById('ts-auth-btn');\n          authElem.textContent = triggerText;\n          samlCompletionPromise = samlCompletionPromise || new Promise(function (resolve, reject) {\n            window.addEventListener('message', function (e) {\n              if (e.data.type === EmbedEvent.SAMLComplete) {\n                e.source.close();\n                resolve();\n              }\n            });\n          });\n          authElem.addEventListener('click', function () {\n            if (samlAuthWindow === null || samlAuthWindow.closed) {\n              samlAuthWindow = window.open(ssoURL, '_blank', 'location=no,height=570,width=520,scrollbars=yes,status=yes');\n            } else {\n              samlAuthWindow.focus();\n            }\n          }, {\n            once: true\n          });\n          return _context9.abrupt(\"return\", samlCompletionPromise);\n        case 7:\n        case \"end\":\n          return _context9.stop();\n      }\n    }, _callee9);\n  }));\n  return _samlPopupFlow.apply(this, arguments);\n}\nvar doSSOAuth = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(embedConfig, ssoEndPoint) {\n    var thoughtSpotHost, loggedIn, ssoURL;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          thoughtSpotHost = embedConfig.thoughtSpotHost;\n          _context3.next = 3;\n          return isLoggedIn(thoughtSpotHost);\n        case 3:\n          loggedIn = _context3.sent;\n          if (!loggedIn) {\n            _context3.next = 8;\n            break;\n          }\n          if (isAtSSORedirectUrl()) {\n            removeSSORedirectUrlMarker();\n          }\n          loggedInStatus = true;\n          return _context3.abrupt(\"return\");\n        case 8:\n          if (!isAtSSORedirectUrl()) {\n            _context3.next = 12;\n            break;\n          }\n          removeSSORedirectUrlMarker();\n          loggedInStatus = false;\n          return _context3.abrupt(\"return\");\n        case 12:\n          ssoURL = \"\".concat(thoughtSpotHost).concat(ssoEndPoint);\n          if (!embedConfig.noRedirect) {\n            _context3.next = 18;\n            break;\n          }\n          _context3.next = 16;\n          return samlPopupFlow(ssoURL, embedConfig.authTriggerContainer, embedConfig.authTriggerText);\n        case 16:\n          loggedInStatus = true;\n          return _context3.abrupt(\"return\");\n        case 18:\n          window.location.href = ssoURL;\n        case 19:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return function doSSOAuth(_x7, _x8) {\n    return _ref3.apply(this, arguments);\n  };\n}();\nexport var doSamlAuth = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(embedConfig) {\n    var thoughtSpotHost, ssoRedirectUrl, ssoEndPoint;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          thoughtSpotHost = embedConfig.thoughtSpotHost; // redirect for SSO, when the SSO authentication is done, this page will be loaded\n          // again and the same JS will execute again.\n          ssoRedirectUrl = embedConfig.noRedirect ? \"\".concat(thoughtSpotHost, \"/v2/#/embed/saml-complete\") : getRedirectUrl(window.location.href, SSO_REDIRECTION_MARKER_GUID, embedConfig.redirectPath); // bring back the page to the same URL\n          ssoEndPoint = \"\".concat(EndPoints.SAML_LOGIN_TEMPLATE(encodeURIComponent(ssoRedirectUrl)));\n          _context4.next = 5;\n          return doSSOAuth(embedConfig, ssoEndPoint);\n        case 5:\n          return _context4.abrupt(\"return\", loggedInStatus);\n        case 6:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n  return function doSamlAuth(_x9) {\n    return _ref4.apply(this, arguments);\n  };\n}();\nexport var doOIDCAuth = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(embedConfig) {\n    var thoughtSpotHost, ssoRedirectUrl, ssoEndPoint;\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) switch (_context5.prev = _context5.next) {\n        case 0:\n          thoughtSpotHost = embedConfig.thoughtSpotHost; // redirect for SSO, when the SSO authentication is done, this page will be loaded\n          // again and the same JS will execute again.\n          ssoRedirectUrl = embedConfig.noRedirect ? \"\".concat(thoughtSpotHost, \"/v2/#/embed/saml-complete\") : getRedirectUrl(window.location.href, SSO_REDIRECTION_MARKER_GUID, embedConfig.redirectPath); // bring back the page to the same URL\n          ssoEndPoint = \"\".concat(EndPoints.OIDC_LOGIN_TEMPLATE(encodeURIComponent(ssoRedirectUrl)));\n          _context5.next = 5;\n          return doSSOAuth(embedConfig, ssoEndPoint);\n        case 5:\n          return _context5.abrupt(\"return\", loggedInStatus);\n        case 6:\n        case \"end\":\n          return _context5.stop();\n      }\n    }, _callee5);\n  }));\n  return function doOIDCAuth(_x10) {\n    return _ref5.apply(this, arguments);\n  };\n}();\nexport var logout = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(embedConfig) {\n    var thoughtSpotHost, response;\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) switch (_context6.prev = _context6.next) {\n        case 0:\n          thoughtSpotHost = embedConfig.thoughtSpotHost;\n          _context6.next = 3;\n          return fetchLogoutService(thoughtSpotHost);\n        case 3:\n          response = _context6.sent;\n          loggedInStatus = false;\n          return _context6.abrupt(\"return\", loggedInStatus);\n        case 6:\n        case \"end\":\n          return _context6.stop();\n      }\n    }, _callee6);\n  }));\n  return function logout(_x11) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n/**\n * Perform authentication on the ThoughtSpot cluster\n * @param embedConfig The embed configuration\n */\nexport var authenticate = /*#__PURE__*/function () {\n  var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(embedConfig) {\n    var authType;\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) switch (_context7.prev = _context7.next) {\n        case 0:\n          authType = embedConfig.authType;\n          _context7.t0 = authType;\n          _context7.next = _context7.t0 === AuthType.SSO ? 4 : _context7.t0 === AuthType.SAMLRedirect ? 4 : _context7.t0 === AuthType.SAML ? 4 : _context7.t0 === AuthType.OIDC ? 5 : _context7.t0 === AuthType.OIDCRedirect ? 5 : _context7.t0 === AuthType.AuthServer ? 6 : _context7.t0 === AuthType.TrustedAuthToken ? 6 : _context7.t0 === AuthType.Basic ? 7 : 8;\n          break;\n        case 4:\n          return _context7.abrupt(\"return\", doSamlAuth(embedConfig));\n        case 5:\n          return _context7.abrupt(\"return\", doOIDCAuth(embedConfig));\n        case 6:\n          return _context7.abrupt(\"return\", doTokenAuth(embedConfig));\n        case 7:\n          return _context7.abrupt(\"return\", doBasicAuth(embedConfig));\n        case 8:\n          return _context7.abrupt(\"return\", Promise.resolve(true));\n        case 9:\n        case \"end\":\n          return _context7.stop();\n      }\n    }, _callee7);\n  }));\n  return function authenticate(_x12) {\n    return _ref7.apply(this, arguments);\n  };\n}();\n/**\n * Check if we are authenticated to the ThoughtSpot cluster\n */\nexport var isAuthenticated = function isAuthenticated() {\n  return loggedInStatus;\n};","map":{"version":3,"mappings":"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","names":["initMixpanel","AuthType","EmbedEvent","getDOMNode","getRedirectUrl","fetchSessionInfoService","fetchAuthTokenService","fetchAuthService","fetchBasicAuthService","fetchLogoutService","fetchAuthPostService","loggedInStatus","samlAuthWindow","samlCompletionPromise","sessionInfo","releaseVersion","SSO_REDIRECTION_MARKER_GUID","EndPoints","AUTH_VERIFICATION","SAML_LOGIN_TEMPLATE","targetUrl","OIDC_LOGIN_TEMPLATE","TOKEN_LOGIN","BASIC_LOGIN","LOGOUT","AuthFailureType","AuthStatus","isLoggedIn","thoughtSpotHost","authVerificationUrl","response","json","sessionInfoResp","status","getReleaseVersion","getSessionInfo","initSession","sessionDetails","DUPLICATE_TOKEN_ERR","prevAuthToken","alertForDuplicateToken","authtoken","alert","Error","isAtSSORedirectUrl","window","location","href","indexOf","removeSSORedirectUrlMarker","hash","replace","doTokenAuth","embedConfig","username","authEndpoint","getAuthToken","authToken","text","resp","ok","type","detectCookieAccessSlow","doBasicAuth","password","loggedIn","samlPopupFlow","ssoURL","triggerContainer","triggerText","containerEl","innerHTML","authElem","document","getElementById","textContent","Promise","resolve","reject","addEventListener","e","data","SAMLComplete","source","close","closed","open","focus","once","doSSOAuth","ssoEndPoint","noRedirect","authTriggerContainer","authTriggerText","doSamlAuth","ssoRedirectUrl","redirectPath","encodeURIComponent","doOIDCAuth","logout","authenticate","authType","SSO","SAMLRedirect","SAML","OIDC","OIDCRedirect","AuthServer","TrustedAuthToken","Basic","isAuthenticated"],"sources":["C:\\Users\\user\\Desktop\\kipithonteam2\\myapp\\snowspot-app\\node_modules\\@thoughtspot\\visual-embed-sdk\\src\\auth.ts"],"sourcesContent":["import { initMixpanel } from './mixpanel-service';\nimport { AuthType, DOMSelector, EmbedConfig, EmbedEvent, Param } from './types';\nimport { getDOMNode, getRedirectUrl } from './utils';\n// eslint-disable-next-line import/no-cycle\nimport {\n    fetchSessionInfoService,\n    fetchAuthTokenService,\n    fetchAuthService,\n    fetchBasicAuthService,\n    fetchLogoutService,\n    fetchAuthPostService,\n} from './utils/authService';\n\n// eslint-disable-next-line import/no-mutable-exports\nexport let loggedInStatus = false;\n// eslint-disable-next-line import/no-mutable-exports\nexport let samlAuthWindow: Window = null;\n// eslint-disable-next-line import/no-mutable-exports\nexport let samlCompletionPromise: Promise<void> = null;\nlet sessionInfo: any = null;\nlet releaseVersion = '';\n\nexport const SSO_REDIRECTION_MARKER_GUID =\n    '5e16222e-ef02-43e9-9fbd-24226bf3ce5b';\n\nexport const EndPoints = {\n    AUTH_VERIFICATION: '/callosum/v1/session/info',\n    SAML_LOGIN_TEMPLATE: (targetUrl: string) =>\n        `/callosum/v1/saml/login?targetURLPath=${targetUrl}`,\n    OIDC_LOGIN_TEMPLATE: (targetUrl: string) =>\n        `/callosum/v1/oidc/login?targetURLPath=${targetUrl}`,\n    TOKEN_LOGIN: '/callosum/v1/session/login/token',\n    BASIC_LOGIN: '/callosum/v1/session/login',\n    LOGOUT: '/callosum/v1/session/logout',\n};\n\nexport enum AuthFailureType {\n    SDK = 'SDK',\n    NO_COOKIE_ACCESS = 'NO_COOKIE_ACCESS',\n    EXPIRY = 'EXPIRY',\n    OTHER = 'OTHER',\n}\n\nexport enum AuthStatus {\n    /**\n     * Emits when the SDK fails to authenticate\n     */\n    FAILURE = 'FAILURE',\n    /**\n     * Emits when the SDK authenticates successfully\n     */\n    SDK_SUCCESS = 'SDK_SUCCESS',\n    /**\n     * Emits when the app sends an authentication success message\n     */\n    SUCCESS = 'SUCCESS',\n    /**\n     * Emits when a user logs out\n     */\n    LOGOUT = 'LOGOUT',\n}\n\n/**\n * Check if we are logged into the ThoughtSpot cluster\n * @param thoughtSpotHost The ThoughtSpot cluster hostname or IP\n */\nasync function isLoggedIn(thoughtSpotHost: string): Promise<boolean> {\n    const authVerificationUrl = `${thoughtSpotHost}${EndPoints.AUTH_VERIFICATION}`;\n    let response = null;\n    try {\n        response = await fetchSessionInfoService(authVerificationUrl);\n        const sessionInfoResp = await response.json();\n        releaseVersion = sessionInfoResp.releaseVersion;\n    } catch (e) {\n        return false;\n    }\n    return response.status === 200;\n}\n\n/**\n * Return releaseVersion if available\n */\nexport function getReleaseVersion() {\n    return releaseVersion;\n}\n\n/**\n * Return sessionInfo if available else make a loggedIn check to fetch the sessionInfo\n */\nexport function getSessionInfo() {\n    return sessionInfo;\n}\n\nexport function initSession(sessionDetails: any) {\n    sessionInfo = sessionDetails;\n    initMixpanel(sessionInfo);\n}\n\nconst DUPLICATE_TOKEN_ERR =\n    'Duplicate token, please issue a new token every time getAuthToken callback is called.' +\n    'See https://developers.thoughtspot.com/docs/?pageid=embed-auth#trusted-auth-embed for more details.';\nlet prevAuthToken: string = null;\nfunction alertForDuplicateToken(authtoken: string) {\n    if (prevAuthToken === authtoken) {\n        // eslint-disable-next-line no-alert\n        alert(DUPLICATE_TOKEN_ERR);\n        throw new Error(DUPLICATE_TOKEN_ERR);\n    }\n    prevAuthToken = authtoken;\n}\n\n/**\n * Check if we are stuck at the SSO redirect URL\n */\nfunction isAtSSORedirectUrl(): boolean {\n    return window.location.href.indexOf(SSO_REDIRECTION_MARKER_GUID) >= 0;\n}\n\n/**\n * Remove the SSO redirect URL marker\n */\nfunction removeSSORedirectUrlMarker(): void {\n    // Note (sunny): This will leave a # around even if it was not in the URL\n    // to begin with. Trying to remove the hash by changing window.location will reload\n    // the page which we don't want. We'll live with adding an unnecessary hash to the\n    // parent page URL until we find any use case where that creates an issue.\n    window.location.hash = window.location.hash.replace(\n        SSO_REDIRECTION_MARKER_GUID,\n        '',\n    );\n}\n\n/**\n * Perform token based authentication\n * @param embedConfig The embed configuration\n */\nexport const doTokenAuth = async (\n    embedConfig: EmbedConfig,\n): Promise<boolean> => {\n    const {\n        thoughtSpotHost,\n        username,\n        authEndpoint,\n        getAuthToken,\n    } = embedConfig;\n    if (!authEndpoint && !getAuthToken) {\n        throw new Error(\n            'Either auth endpoint or getAuthToken function must be provided',\n        );\n    }\n    loggedInStatus = await isLoggedIn(thoughtSpotHost);\n    if (!loggedInStatus) {\n        let authToken = null;\n        if (getAuthToken) {\n            authToken = await getAuthToken();\n            alertForDuplicateToken(authToken);\n        } else {\n            const response = await fetchAuthTokenService(authEndpoint);\n            authToken = await response.text();\n        }\n        let resp;\n        try {\n            resp = await fetchAuthPostService(\n                thoughtSpotHost,\n                username,\n                authToken,\n            );\n        } catch (e) {\n            resp = await fetchAuthService(thoughtSpotHost, username, authToken);\n        }\n        // token login issues a 302 when successful\n        loggedInStatus = resp.ok || resp.type === 'opaqueredirect';\n        if (loggedInStatus && embedConfig.detectCookieAccessSlow) {\n            // When 3rd party cookie access is blocked, this will fail because cookies will\n            // not be sent with the call.\n            loggedInStatus = await isLoggedIn(thoughtSpotHost);\n        }\n    }\n    return loggedInStatus;\n};\n\n/**\n * Perform basic authentication to the ThoughtSpot cluster using the cluster\n * credentials.\n *\n * Warning: This feature is primarily intended for developer testing. It is\n * strongly advised not to use this authentication method in production.\n * @param embedConfig The embed configuration\n */\nexport const doBasicAuth = async (\n    embedConfig: EmbedConfig,\n): Promise<boolean> => {\n    const { thoughtSpotHost, username, password } = embedConfig;\n    const loggedIn = await isLoggedIn(thoughtSpotHost);\n    if (!loggedIn) {\n        const response = await fetchBasicAuthService(\n            thoughtSpotHost,\n            username,\n            password,\n        );\n        loggedInStatus = response.ok;\n        if (embedConfig.detectCookieAccessSlow) {\n            loggedInStatus = await isLoggedIn(thoughtSpotHost);\n        }\n    } else {\n        loggedInStatus = true;\n    }\n    return loggedInStatus;\n};\n\nasync function samlPopupFlow(\n    ssoURL: string,\n    triggerContainer: DOMSelector,\n    triggerText: string,\n) {\n    const containerEl = getDOMNode(triggerContainer);\n    containerEl.innerHTML =\n        '<button id=\"ts-auth-btn\" class=\"ts-auth-btn\" style=\"margin: auto;\"></button>';\n    const authElem = document.getElementById('ts-auth-btn');\n    authElem.textContent = triggerText;\n    samlCompletionPromise =\n        samlCompletionPromise ||\n        new Promise<void>((resolve, reject) => {\n            window.addEventListener('message', (e) => {\n                if (e.data.type === EmbedEvent.SAMLComplete) {\n                    (e.source as Window).close();\n                    resolve();\n                }\n            });\n        });\n    authElem.addEventListener(\n        'click',\n        () => {\n            if (samlAuthWindow === null || samlAuthWindow.closed) {\n                samlAuthWindow = window.open(\n                    ssoURL,\n                    '_blank',\n                    'location=no,height=570,width=520,scrollbars=yes,status=yes',\n                );\n            } else {\n                samlAuthWindow.focus();\n            }\n        },\n        { once: true },\n    );\n    return samlCompletionPromise;\n}\n\n/**\n * Perform SAML authentication\n * @param embedConfig The embed configuration\n */\nconst doSSOAuth = async (\n    embedConfig: EmbedConfig,\n    ssoEndPoint: string,\n): Promise<void> => {\n    const { thoughtSpotHost } = embedConfig;\n    const loggedIn = await isLoggedIn(thoughtSpotHost);\n    if (loggedIn) {\n        if (isAtSSORedirectUrl()) {\n            removeSSORedirectUrlMarker();\n        }\n        loggedInStatus = true;\n        return;\n    }\n\n    // we have already tried authentication and it did not succeed, restore\n    // the current URL to the original one and invoke the callback.\n    if (isAtSSORedirectUrl()) {\n        removeSSORedirectUrlMarker();\n        loggedInStatus = false;\n        return;\n    }\n\n    const ssoURL = `${thoughtSpotHost}${ssoEndPoint}`;\n    if (embedConfig.noRedirect) {\n        await samlPopupFlow(\n            ssoURL,\n            embedConfig.authTriggerContainer,\n            embedConfig.authTriggerText,\n        );\n        loggedInStatus = true;\n        return;\n    }\n\n    window.location.href = ssoURL;\n};\n\nexport const doSamlAuth = async (embedConfig: EmbedConfig) => {\n    const { thoughtSpotHost } = embedConfig;\n    // redirect for SSO, when the SSO authentication is done, this page will be loaded\n    // again and the same JS will execute again.\n    const ssoRedirectUrl = embedConfig.noRedirect\n        ? `${thoughtSpotHost}/v2/#/embed/saml-complete`\n        : getRedirectUrl(\n              window.location.href,\n              SSO_REDIRECTION_MARKER_GUID,\n              embedConfig.redirectPath,\n          );\n\n    // bring back the page to the same URL\n    const ssoEndPoint = `${EndPoints.SAML_LOGIN_TEMPLATE(\n        encodeURIComponent(ssoRedirectUrl),\n    )}`;\n\n    await doSSOAuth(embedConfig, ssoEndPoint);\n    return loggedInStatus;\n};\n\nexport const doOIDCAuth = async (embedConfig: EmbedConfig) => {\n    const { thoughtSpotHost } = embedConfig;\n    // redirect for SSO, when the SSO authentication is done, this page will be loaded\n    // again and the same JS will execute again.\n    const ssoRedirectUrl = embedConfig.noRedirect\n        ? `${thoughtSpotHost}/v2/#/embed/saml-complete`\n        : getRedirectUrl(\n              window.location.href,\n              SSO_REDIRECTION_MARKER_GUID,\n              embedConfig.redirectPath,\n          );\n\n    // bring back the page to the same URL\n    const ssoEndPoint = `${EndPoints.OIDC_LOGIN_TEMPLATE(\n        encodeURIComponent(ssoRedirectUrl),\n    )}`;\n\n    await doSSOAuth(embedConfig, ssoEndPoint);\n    return loggedInStatus;\n};\n\nexport const logout = async (embedConfig: EmbedConfig): Promise<boolean> => {\n    const { thoughtSpotHost } = embedConfig;\n    const response = await fetchLogoutService(thoughtSpotHost);\n    loggedInStatus = false;\n    return loggedInStatus;\n};\n\n/**\n * Perform authentication on the ThoughtSpot cluster\n * @param embedConfig The embed configuration\n */\nexport const authenticate = async (\n    embedConfig: EmbedConfig,\n): Promise<boolean> => {\n    const { authType } = embedConfig;\n    switch (authType) {\n        case AuthType.SSO:\n        case AuthType.SAMLRedirect:\n        case AuthType.SAML:\n            return doSamlAuth(embedConfig);\n        case AuthType.OIDC:\n        case AuthType.OIDCRedirect:\n            return doOIDCAuth(embedConfig);\n        case AuthType.AuthServer:\n        case AuthType.TrustedAuthToken:\n            return doTokenAuth(embedConfig);\n        case AuthType.Basic:\n            return doBasicAuth(embedConfig);\n        default:\n            return Promise.resolve(true);\n    }\n};\n\n/**\n * Check if we are authenticated to the ThoughtSpot cluster\n */\nexport const isAuthenticated = (): boolean => loggedInStatus;\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { initMixpanel } from './mixpanel-service';\nimport { AuthType, EmbedEvent } from './types';\nimport { getDOMNode, getRedirectUrl } from './utils';\n// eslint-disable-next-line import/no-cycle\nimport { fetchSessionInfoService, fetchAuthTokenService, fetchAuthService, fetchBasicAuthService, fetchLogoutService, fetchAuthPostService } from './utils/authService';\n// eslint-disable-next-line import/no-mutable-exports\nexport let loggedInStatus = false;\n// eslint-disable-next-line import/no-mutable-exports\nexport let samlAuthWindow = null;\n// eslint-disable-next-line import/no-mutable-exports\nexport let samlCompletionPromise = null;\nlet sessionInfo = null;\nlet releaseVersion = '';\nexport const SSO_REDIRECTION_MARKER_GUID = '5e16222e-ef02-43e9-9fbd-24226bf3ce5b';\nexport const EndPoints = {\n  AUTH_VERIFICATION: '/callosum/v1/session/info',\n  SAML_LOGIN_TEMPLATE: targetUrl => `/callosum/v1/saml/login?targetURLPath=${targetUrl}`,\n  OIDC_LOGIN_TEMPLATE: targetUrl => `/callosum/v1/oidc/login?targetURLPath=${targetUrl}`,\n  TOKEN_LOGIN: '/callosum/v1/session/login/token',\n  BASIC_LOGIN: '/callosum/v1/session/login',\n  LOGOUT: '/callosum/v1/session/logout'\n};\nexport var AuthFailureType;\n(function (AuthFailureType) {\n  AuthFailureType[\"SDK\"] = \"SDK\";\n  AuthFailureType[\"NO_COOKIE_ACCESS\"] = \"NO_COOKIE_ACCESS\";\n  AuthFailureType[\"EXPIRY\"] = \"EXPIRY\";\n  AuthFailureType[\"OTHER\"] = \"OTHER\";\n})(AuthFailureType || (AuthFailureType = {}));\nexport var AuthStatus;\n(function (AuthStatus) {\n  /**\n   * Emits when the SDK fails to authenticate\n   */\n  AuthStatus[\"FAILURE\"] = \"FAILURE\";\n  /**\n   * Emits when the SDK authenticates successfully\n   */\n  AuthStatus[\"SDK_SUCCESS\"] = \"SDK_SUCCESS\";\n  /**\n   * Emits when the app sends an authentication success message\n   */\n  AuthStatus[\"SUCCESS\"] = \"SUCCESS\";\n  /**\n   * Emits when a user logs out\n   */\n  AuthStatus[\"LOGOUT\"] = \"LOGOUT\";\n})(AuthStatus || (AuthStatus = {}));\n/**\n * Check if we are logged into the ThoughtSpot cluster\n * @param thoughtSpotHost The ThoughtSpot cluster hostname or IP\n */\nasync function isLoggedIn(thoughtSpotHost) {\n  const authVerificationUrl = `${thoughtSpotHost}${EndPoints.AUTH_VERIFICATION}`;\n  let response = null;\n  try {\n    response = await fetchSessionInfoService(authVerificationUrl);\n    const sessionInfoResp = await response.json();\n    releaseVersion = sessionInfoResp.releaseVersion;\n  } catch (e) {\n    return false;\n  }\n  return response.status === 200;\n}\n/**\n * Return releaseVersion if available\n */\nexport function getReleaseVersion() {\n  return releaseVersion;\n}\n/**\n * Return sessionInfo if available else make a loggedIn check to fetch the sessionInfo\n */\nexport function getSessionInfo() {\n  return sessionInfo;\n}\nexport function initSession(sessionDetails) {\n  sessionInfo = sessionDetails;\n  initMixpanel(sessionInfo);\n}\nconst DUPLICATE_TOKEN_ERR = 'Duplicate token, please issue a new token every time getAuthToken callback is called.' + 'See https://developers.thoughtspot.com/docs/?pageid=embed-auth#trusted-auth-embed for more details.';\nlet prevAuthToken = null;\nfunction alertForDuplicateToken(authtoken) {\n  if (prevAuthToken === authtoken) {\n    // eslint-disable-next-line no-alert\n    alert(DUPLICATE_TOKEN_ERR);\n    throw new Error(DUPLICATE_TOKEN_ERR);\n  }\n  prevAuthToken = authtoken;\n}\n/**\n * Check if we are stuck at the SSO redirect URL\n */\nfunction isAtSSORedirectUrl() {\n  return window.location.href.indexOf(SSO_REDIRECTION_MARKER_GUID) >= 0;\n}\n/**\n * Remove the SSO redirect URL marker\n */\nfunction removeSSORedirectUrlMarker() {\n  // Note (sunny): This will leave a # around even if it was not in the URL\n  // to begin with. Trying to remove the hash by changing window.location will reload\n  // the page which we don't want. We'll live with adding an unnecessary hash to the\n  // parent page URL until we find any use case where that creates an issue.\n  window.location.hash = window.location.hash.replace(SSO_REDIRECTION_MARKER_GUID, '');\n}\n/**\n * Perform token based authentication\n * @param embedConfig The embed configuration\n */\nexport const doTokenAuth = async embedConfig => {\n  const {\n    thoughtSpotHost,\n    username,\n    authEndpoint,\n    getAuthToken\n  } = embedConfig;\n  if (!authEndpoint && !getAuthToken) {\n    throw new Error('Either auth endpoint or getAuthToken function must be provided');\n  }\n  loggedInStatus = await isLoggedIn(thoughtSpotHost);\n  if (!loggedInStatus) {\n    let authToken = null;\n    if (getAuthToken) {\n      authToken = await getAuthToken();\n      alertForDuplicateToken(authToken);\n    } else {\n      const response = await fetchAuthTokenService(authEndpoint);\n      authToken = await response.text();\n    }\n    let resp;\n    try {\n      resp = await fetchAuthPostService(thoughtSpotHost, username, authToken);\n    } catch (e) {\n      resp = await fetchAuthService(thoughtSpotHost, username, authToken);\n    }\n    // token login issues a 302 when successful\n    loggedInStatus = resp.ok || resp.type === 'opaqueredirect';\n    if (loggedInStatus && embedConfig.detectCookieAccessSlow) {\n      // When 3rd party cookie access is blocked, this will fail because cookies will\n      // not be sent with the call.\n      loggedInStatus = await isLoggedIn(thoughtSpotHost);\n    }\n  }\n  return loggedInStatus;\n};\n/**\n * Perform basic authentication to the ThoughtSpot cluster using the cluster\n * credentials.\n *\n * Warning: This feature is primarily intended for developer testing. It is\n * strongly advised not to use this authentication method in production.\n * @param embedConfig The embed configuration\n */\nexport const doBasicAuth = async embedConfig => {\n  const {\n    thoughtSpotHost,\n    username,\n    password\n  } = embedConfig;\n  const loggedIn = await isLoggedIn(thoughtSpotHost);\n  if (!loggedIn) {\n    const response = await fetchBasicAuthService(thoughtSpotHost, username, password);\n    loggedInStatus = response.ok;\n    if (embedConfig.detectCookieAccessSlow) {\n      loggedInStatus = await isLoggedIn(thoughtSpotHost);\n    }\n  } else {\n    loggedInStatus = true;\n  }\n  return loggedInStatus;\n};\nasync function samlPopupFlow(ssoURL, triggerContainer, triggerText) {\n  const containerEl = getDOMNode(triggerContainer);\n  containerEl.innerHTML = '<button id=\"ts-auth-btn\" class=\"ts-auth-btn\" style=\"margin: auto;\"></button>';\n  const authElem = document.getElementById('ts-auth-btn');\n  authElem.textContent = triggerText;\n  samlCompletionPromise = samlCompletionPromise || new Promise((resolve, reject) => {\n    window.addEventListener('message', e => {\n      if (e.data.type === EmbedEvent.SAMLComplete) {\n        e.source.close();\n        resolve();\n      }\n    });\n  });\n  authElem.addEventListener('click', () => {\n    if (samlAuthWindow === null || samlAuthWindow.closed) {\n      samlAuthWindow = window.open(ssoURL, '_blank', 'location=no,height=570,width=520,scrollbars=yes,status=yes');\n    } else {\n      samlAuthWindow.focus();\n    }\n  }, {\n    once: true\n  });\n  return samlCompletionPromise;\n}\n/**\n * Perform SAML authentication\n * @param embedConfig The embed configuration\n */\nconst doSSOAuth = async (embedConfig, ssoEndPoint) => {\n  const {\n    thoughtSpotHost\n  } = embedConfig;\n  const loggedIn = await isLoggedIn(thoughtSpotHost);\n  if (loggedIn) {\n    if (isAtSSORedirectUrl()) {\n      removeSSORedirectUrlMarker();\n    }\n    loggedInStatus = true;\n    return;\n  }\n  // we have already tried authentication and it did not succeed, restore\n  // the current URL to the original one and invoke the callback.\n  if (isAtSSORedirectUrl()) {\n    removeSSORedirectUrlMarker();\n    loggedInStatus = false;\n    return;\n  }\n  const ssoURL = `${thoughtSpotHost}${ssoEndPoint}`;\n  if (embedConfig.noRedirect) {\n    await samlPopupFlow(ssoURL, embedConfig.authTriggerContainer, embedConfig.authTriggerText);\n    loggedInStatus = true;\n    return;\n  }\n  window.location.href = ssoURL;\n};\nexport const doSamlAuth = async embedConfig => {\n  const {\n    thoughtSpotHost\n  } = embedConfig;\n  // redirect for SSO, when the SSO authentication is done, this page will be loaded\n  // again and the same JS will execute again.\n  const ssoRedirectUrl = embedConfig.noRedirect ? `${thoughtSpotHost}/v2/#/embed/saml-complete` : getRedirectUrl(window.location.href, SSO_REDIRECTION_MARKER_GUID, embedConfig.redirectPath);\n  // bring back the page to the same URL\n  const ssoEndPoint = `${EndPoints.SAML_LOGIN_TEMPLATE(encodeURIComponent(ssoRedirectUrl))}`;\n  await doSSOAuth(embedConfig, ssoEndPoint);\n  return loggedInStatus;\n};\nexport const doOIDCAuth = async embedConfig => {\n  const {\n    thoughtSpotHost\n  } = embedConfig;\n  // redirect for SSO, when the SSO authentication is done, this page will be loaded\n  // again and the same JS will execute again.\n  const ssoRedirectUrl = embedConfig.noRedirect ? `${thoughtSpotHost}/v2/#/embed/saml-complete` : getRedirectUrl(window.location.href, SSO_REDIRECTION_MARKER_GUID, embedConfig.redirectPath);\n  // bring back the page to the same URL\n  const ssoEndPoint = `${EndPoints.OIDC_LOGIN_TEMPLATE(encodeURIComponent(ssoRedirectUrl))}`;\n  await doSSOAuth(embedConfig, ssoEndPoint);\n  return loggedInStatus;\n};\nexport const logout = async embedConfig => {\n  const {\n    thoughtSpotHost\n  } = embedConfig;\n  const response = await fetchLogoutService(thoughtSpotHost);\n  loggedInStatus = false;\n  return loggedInStatus;\n};\n/**\n * Perform authentication on the ThoughtSpot cluster\n * @param embedConfig The embed configuration\n */\nexport const authenticate = async embedConfig => {\n  const {\n    authType\n  } = embedConfig;\n  switch (authType) {\n    case AuthType.SSO:\n    case AuthType.SAMLRedirect:\n    case AuthType.SAML:\n      return doSamlAuth(embedConfig);\n    case AuthType.OIDC:\n    case AuthType.OIDCRedirect:\n      return doOIDCAuth(embedConfig);\n    case AuthType.AuthServer:\n    case AuthType.TrustedAuthToken:\n      return doTokenAuth(embedConfig);\n    case AuthType.Basic:\n      return doBasicAuth(embedConfig);\n    default:\n      return Promise.resolve(true);\n  }\n};\n/**\n * Check if we are authenticated to the ThoughtSpot cluster\n */\nexport const isAuthenticated = () => loggedInStatus;","map":{"version":3,"mappings":"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","names":["initMixpanel","AuthType","EmbedEvent","getDOMNode","getRedirectUrl","fetchSessionInfoService","fetchAuthTokenService","fetchAuthService","fetchBasicAuthService","fetchLogoutService","fetchAuthPostService","loggedInStatus","samlAuthWindow","samlCompletionPromise","sessionInfo","releaseVersion","SSO_REDIRECTION_MARKER_GUID","EndPoints","AUTH_VERIFICATION","SAML_LOGIN_TEMPLATE","targetUrl","OIDC_LOGIN_TEMPLATE","TOKEN_LOGIN","BASIC_LOGIN","LOGOUT","AuthFailureType","AuthStatus","isLoggedIn","thoughtSpotHost","authVerificationUrl","response","sessionInfoResp","json","e","status","getReleaseVersion","getSessionInfo","initSession","sessionDetails","DUPLICATE_TOKEN_ERR","prevAuthToken","alertForDuplicateToken","authtoken","alert","Error","isAtSSORedirectUrl","window","location","href","indexOf","removeSSORedirectUrlMarker","hash","replace","doTokenAuth","embedConfig","username","authEndpoint","getAuthToken","authToken","text","resp","ok","type","detectCookieAccessSlow","doBasicAuth","password","loggedIn","samlPopupFlow","ssoURL","triggerContainer","triggerText","containerEl","innerHTML","authElem","document","getElementById","textContent","Promise","resolve","reject","addEventListener","data","SAMLComplete","source","close","closed","open","focus","once","doSSOAuth","ssoEndPoint","noRedirect","authTriggerContainer","authTriggerText","doSamlAuth","ssoRedirectUrl","redirectPath","encodeURIComponent","doOIDCAuth","logout","authenticate","authType","SSO","SAMLRedirect","SAML","OIDC","OIDCRedirect","AuthServer","TrustedAuthToken","Basic","isAuthenticated"],"sources":["C:\\Users\\user\\Desktop\\kipithonteam2\\myapp\\snowspot-app\\node_modules\\@thoughtspot\\visual-embed-sdk\\src\\auth.ts"],"sourcesContent":["import { initMixpanel } from './mixpanel-service';\nimport { AuthType, DOMSelector, EmbedConfig, EmbedEvent, Param } from './types';\nimport { getDOMNode, getRedirectUrl } from './utils';\n// eslint-disable-next-line import/no-cycle\nimport {\n    fetchSessionInfoService,\n    fetchAuthTokenService,\n    fetchAuthService,\n    fetchBasicAuthService,\n    fetchLogoutService,\n    fetchAuthPostService,\n} from './utils/authService';\n\n// eslint-disable-next-line import/no-mutable-exports\nexport let loggedInStatus = false;\n// eslint-disable-next-line import/no-mutable-exports\nexport let samlAuthWindow: Window = null;\n// eslint-disable-next-line import/no-mutable-exports\nexport let samlCompletionPromise: Promise<void> = null;\nlet sessionInfo: any = null;\nlet releaseVersion = '';\n\nexport const SSO_REDIRECTION_MARKER_GUID =\n    '5e16222e-ef02-43e9-9fbd-24226bf3ce5b';\n\nexport const EndPoints = {\n    AUTH_VERIFICATION: '/callosum/v1/session/info',\n    SAML_LOGIN_TEMPLATE: (targetUrl: string) =>\n        `/callosum/v1/saml/login?targetURLPath=${targetUrl}`,\n    OIDC_LOGIN_TEMPLATE: (targetUrl: string) =>\n        `/callosum/v1/oidc/login?targetURLPath=${targetUrl}`,\n    TOKEN_LOGIN: '/callosum/v1/session/login/token',\n    BASIC_LOGIN: '/callosum/v1/session/login',\n    LOGOUT: '/callosum/v1/session/logout',\n};\n\nexport enum AuthFailureType {\n    SDK = 'SDK',\n    NO_COOKIE_ACCESS = 'NO_COOKIE_ACCESS',\n    EXPIRY = 'EXPIRY',\n    OTHER = 'OTHER',\n}\n\nexport enum AuthStatus {\n    /**\n     * Emits when the SDK fails to authenticate\n     */\n    FAILURE = 'FAILURE',\n    /**\n     * Emits when the SDK authenticates successfully\n     */\n    SDK_SUCCESS = 'SDK_SUCCESS',\n    /**\n     * Emits when the app sends an authentication success message\n     */\n    SUCCESS = 'SUCCESS',\n    /**\n     * Emits when a user logs out\n     */\n    LOGOUT = 'LOGOUT',\n}\n\n/**\n * Check if we are logged into the ThoughtSpot cluster\n * @param thoughtSpotHost The ThoughtSpot cluster hostname or IP\n */\nasync function isLoggedIn(thoughtSpotHost: string): Promise<boolean> {\n    const authVerificationUrl = `${thoughtSpotHost}${EndPoints.AUTH_VERIFICATION}`;\n    let response = null;\n    try {\n        response = await fetchSessionInfoService(authVerificationUrl);\n        const sessionInfoResp = await response.json();\n        releaseVersion = sessionInfoResp.releaseVersion;\n    } catch (e) {\n        return false;\n    }\n    return response.status === 200;\n}\n\n/**\n * Return releaseVersion if available\n */\nexport function getReleaseVersion() {\n    return releaseVersion;\n}\n\n/**\n * Return sessionInfo if available else make a loggedIn check to fetch the sessionInfo\n */\nexport function getSessionInfo() {\n    return sessionInfo;\n}\n\nexport function initSession(sessionDetails: any) {\n    sessionInfo = sessionDetails;\n    initMixpanel(sessionInfo);\n}\n\nconst DUPLICATE_TOKEN_ERR =\n    'Duplicate token, please issue a new token every time getAuthToken callback is called.' +\n    'See https://developers.thoughtspot.com/docs/?pageid=embed-auth#trusted-auth-embed for more details.';\nlet prevAuthToken: string = null;\nfunction alertForDuplicateToken(authtoken: string) {\n    if (prevAuthToken === authtoken) {\n        // eslint-disable-next-line no-alert\n        alert(DUPLICATE_TOKEN_ERR);\n        throw new Error(DUPLICATE_TOKEN_ERR);\n    }\n    prevAuthToken = authtoken;\n}\n\n/**\n * Check if we are stuck at the SSO redirect URL\n */\nfunction isAtSSORedirectUrl(): boolean {\n    return window.location.href.indexOf(SSO_REDIRECTION_MARKER_GUID) >= 0;\n}\n\n/**\n * Remove the SSO redirect URL marker\n */\nfunction removeSSORedirectUrlMarker(): void {\n    // Note (sunny): This will leave a # around even if it was not in the URL\n    // to begin with. Trying to remove the hash by changing window.location will reload\n    // the page which we don't want. We'll live with adding an unnecessary hash to the\n    // parent page URL until we find any use case where that creates an issue.\n    window.location.hash = window.location.hash.replace(\n        SSO_REDIRECTION_MARKER_GUID,\n        '',\n    );\n}\n\n/**\n * Perform token based authentication\n * @param embedConfig The embed configuration\n */\nexport const doTokenAuth = async (\n    embedConfig: EmbedConfig,\n): Promise<boolean> => {\n    const {\n        thoughtSpotHost,\n        username,\n        authEndpoint,\n        getAuthToken,\n    } = embedConfig;\n    if (!authEndpoint && !getAuthToken) {\n        throw new Error(\n            'Either auth endpoint or getAuthToken function must be provided',\n        );\n    }\n    loggedInStatus = await isLoggedIn(thoughtSpotHost);\n    if (!loggedInStatus) {\n        let authToken = null;\n        if (getAuthToken) {\n            authToken = await getAuthToken();\n            alertForDuplicateToken(authToken);\n        } else {\n            const response = await fetchAuthTokenService(authEndpoint);\n            authToken = await response.text();\n        }\n        let resp;\n        try {\n            resp = await fetchAuthPostService(\n                thoughtSpotHost,\n                username,\n                authToken,\n            );\n        } catch (e) {\n            resp = await fetchAuthService(thoughtSpotHost, username, authToken);\n        }\n        // token login issues a 302 when successful\n        loggedInStatus = resp.ok || resp.type === 'opaqueredirect';\n        if (loggedInStatus && embedConfig.detectCookieAccessSlow) {\n            // When 3rd party cookie access is blocked, this will fail because cookies will\n            // not be sent with the call.\n            loggedInStatus = await isLoggedIn(thoughtSpotHost);\n        }\n    }\n    return loggedInStatus;\n};\n\n/**\n * Perform basic authentication to the ThoughtSpot cluster using the cluster\n * credentials.\n *\n * Warning: This feature is primarily intended for developer testing. It is\n * strongly advised not to use this authentication method in production.\n * @param embedConfig The embed configuration\n */\nexport const doBasicAuth = async (\n    embedConfig: EmbedConfig,\n): Promise<boolean> => {\n    const { thoughtSpotHost, username, password } = embedConfig;\n    const loggedIn = await isLoggedIn(thoughtSpotHost);\n    if (!loggedIn) {\n        const response = await fetchBasicAuthService(\n            thoughtSpotHost,\n            username,\n            password,\n        );\n        loggedInStatus = response.ok;\n        if (embedConfig.detectCookieAccessSlow) {\n            loggedInStatus = await isLoggedIn(thoughtSpotHost);\n        }\n    } else {\n        loggedInStatus = true;\n    }\n    return loggedInStatus;\n};\n\nasync function samlPopupFlow(\n    ssoURL: string,\n    triggerContainer: DOMSelector,\n    triggerText: string,\n) {\n    const containerEl = getDOMNode(triggerContainer);\n    containerEl.innerHTML =\n        '<button id=\"ts-auth-btn\" class=\"ts-auth-btn\" style=\"margin: auto;\"></button>';\n    const authElem = document.getElementById('ts-auth-btn');\n    authElem.textContent = triggerText;\n    samlCompletionPromise =\n        samlCompletionPromise ||\n        new Promise<void>((resolve, reject) => {\n            window.addEventListener('message', (e) => {\n                if (e.data.type === EmbedEvent.SAMLComplete) {\n                    (e.source as Window).close();\n                    resolve();\n                }\n            });\n        });\n    authElem.addEventListener(\n        'click',\n        () => {\n            if (samlAuthWindow === null || samlAuthWindow.closed) {\n                samlAuthWindow = window.open(\n                    ssoURL,\n                    '_blank',\n                    'location=no,height=570,width=520,scrollbars=yes,status=yes',\n                );\n            } else {\n                samlAuthWindow.focus();\n            }\n        },\n        { once: true },\n    );\n    return samlCompletionPromise;\n}\n\n/**\n * Perform SAML authentication\n * @param embedConfig The embed configuration\n */\nconst doSSOAuth = async (\n    embedConfig: EmbedConfig,\n    ssoEndPoint: string,\n): Promise<void> => {\n    const { thoughtSpotHost } = embedConfig;\n    const loggedIn = await isLoggedIn(thoughtSpotHost);\n    if (loggedIn) {\n        if (isAtSSORedirectUrl()) {\n            removeSSORedirectUrlMarker();\n        }\n        loggedInStatus = true;\n        return;\n    }\n\n    // we have already tried authentication and it did not succeed, restore\n    // the current URL to the original one and invoke the callback.\n    if (isAtSSORedirectUrl()) {\n        removeSSORedirectUrlMarker();\n        loggedInStatus = false;\n        return;\n    }\n\n    const ssoURL = `${thoughtSpotHost}${ssoEndPoint}`;\n    if (embedConfig.noRedirect) {\n        await samlPopupFlow(\n            ssoURL,\n            embedConfig.authTriggerContainer,\n            embedConfig.authTriggerText,\n        );\n        loggedInStatus = true;\n        return;\n    }\n\n    window.location.href = ssoURL;\n};\n\nexport const doSamlAuth = async (embedConfig: EmbedConfig) => {\n    const { thoughtSpotHost } = embedConfig;\n    // redirect for SSO, when the SSO authentication is done, this page will be loaded\n    // again and the same JS will execute again.\n    const ssoRedirectUrl = embedConfig.noRedirect\n        ? `${thoughtSpotHost}/v2/#/embed/saml-complete`\n        : getRedirectUrl(\n              window.location.href,\n              SSO_REDIRECTION_MARKER_GUID,\n              embedConfig.redirectPath,\n          );\n\n    // bring back the page to the same URL\n    const ssoEndPoint = `${EndPoints.SAML_LOGIN_TEMPLATE(\n        encodeURIComponent(ssoRedirectUrl),\n    )}`;\n\n    await doSSOAuth(embedConfig, ssoEndPoint);\n    return loggedInStatus;\n};\n\nexport const doOIDCAuth = async (embedConfig: EmbedConfig) => {\n    const { thoughtSpotHost } = embedConfig;\n    // redirect for SSO, when the SSO authentication is done, this page will be loaded\n    // again and the same JS will execute again.\n    const ssoRedirectUrl = embedConfig.noRedirect\n        ? `${thoughtSpotHost}/v2/#/embed/saml-complete`\n        : getRedirectUrl(\n              window.location.href,\n              SSO_REDIRECTION_MARKER_GUID,\n              embedConfig.redirectPath,\n          );\n\n    // bring back the page to the same URL\n    const ssoEndPoint = `${EndPoints.OIDC_LOGIN_TEMPLATE(\n        encodeURIComponent(ssoRedirectUrl),\n    )}`;\n\n    await doSSOAuth(embedConfig, ssoEndPoint);\n    return loggedInStatus;\n};\n\nexport const logout = async (embedConfig: EmbedConfig): Promise<boolean> => {\n    const { thoughtSpotHost } = embedConfig;\n    const response = await fetchLogoutService(thoughtSpotHost);\n    loggedInStatus = false;\n    return loggedInStatus;\n};\n\n/**\n * Perform authentication on the ThoughtSpot cluster\n * @param embedConfig The embed configuration\n */\nexport const authenticate = async (\n    embedConfig: EmbedConfig,\n): Promise<boolean> => {\n    const { authType } = embedConfig;\n    switch (authType) {\n        case AuthType.SSO:\n        case AuthType.SAMLRedirect:\n        case AuthType.SAML:\n            return doSamlAuth(embedConfig);\n        case AuthType.OIDC:\n        case AuthType.OIDCRedirect:\n            return doOIDCAuth(embedConfig);\n        case AuthType.AuthServer:\n        case AuthType.TrustedAuthToken:\n            return doTokenAuth(embedConfig);\n        case AuthType.Basic:\n            return doBasicAuth(embedConfig);\n        default:\n            return Promise.resolve(true);\n    }\n};\n\n/**\n * Check if we are authenticated to the ThoughtSpot cluster\n */\nexport const isAuthenticated = (): boolean => loggedInStatus;\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}